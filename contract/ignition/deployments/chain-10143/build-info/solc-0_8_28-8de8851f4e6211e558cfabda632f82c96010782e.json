{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-8de8851f4e6211e558cfabda632f82c96010782e",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/PayoutManager.sol": "project/contracts/PayoutManager.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/PayoutManager.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IERC20 {\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n    function transfer(address to, uint256 value) external returns (bool);\n}\n\ncontract PayoutManager {\n    struct Payout {\n        address creator; // 批次创建者\n        address token; // 支付 token，address(0) 表示原生币\n        uint256 totalAmount; // 所有收款人理论总额\n        uint256 fundedAmount; // 当前已打入额度（用于检查是否足够）\n        bool closed; // 是否关闭（关闭后不允许再 claim）\n        string title; // 标题/备注 (e.g. \"2023-10 Payroll\")\n        uint8 payoutType; // 类型 (1=Payroll, 2=Grant, 3=Event, etc.)\n    }\n\n    struct PayoutTemplate {\n        address creator;\n        string name; // 模版名称 (e.g. \"Engineering Team Payroll\")\n        address token;\n        address[] recipients;\n        uint256[] amounts;\n    }\n\n    uint256 public nextPayoutId;\n    mapping(uint256 => Payout) public payouts;\n\n    // claimable[payoutId][user] = amount\n    mapping(uint256 => mapping(address => uint256)) public claimable;\n\n    uint256 public nextTemplateId;\n    mapping(uint256 => PayoutTemplate) public templates;\n\n    event PayoutCreated(\n        uint256 indexed payoutId,\n        address indexed creator,\n        address indexed token,\n        uint256 totalAmount,\n        uint256 recipientsCount,\n        string title,\n        uint8 payoutType\n    );\n\n    event PayoutFunded(\n        uint256 indexed payoutId,\n        address indexed from,\n        uint256 amount\n    );\n\n    event PayoutClaimed(\n        uint256 indexed payoutId,\n        address indexed recipient,\n        uint256 amount\n    );\n\n    event PayoutClosed(uint256 indexed payoutId);\n    event RemainingWithdrawn(uint256 indexed payoutId, uint256 amount);\n\n    event TemplateCreated(\n        uint256 indexed templateId,\n        address indexed creator,\n        string name\n    );\n\n    // Internal function to handle payout creation logic\n    function _createPayout(\n        address token,\n        address[] memory recipients,\n        uint256[] memory amounts,\n        string memory title,\n        uint8 payoutType\n    ) internal returns (uint256 payoutId) {\n        require(recipients.length == amounts.length, \"Length mismatch\");\n        require(recipients.length > 0, \"No recipients\");\n\n        uint256 total;\n        payoutId = nextPayoutId;\n        nextPayoutId++;\n\n        for (uint256 i = 0; i < recipients.length; i++) {\n            require(recipients[i] != address(0), \"Zero recipient\");\n            require(amounts[i] > 0, \"Zero amount\");\n            // 独立格子，后续并行 claim\n            claimable[payoutId][recipients[i]] = amounts[i];\n            total += amounts[i];\n        }\n\n        payouts[payoutId] = Payout({\n            creator: msg.sender,\n            token: token,\n            totalAmount: total,\n            fundedAmount: 0,\n            closed: false,\n            title: title,\n            payoutType: payoutType\n        });\n\n        emit PayoutCreated(\n            payoutId,\n            msg.sender,\n            token,\n            total,\n            recipients.length,\n            title,\n            payoutType\n        );\n    }\n\n    function createPayout(\n        address token,\n        address[] calldata recipients,\n        uint256[] calldata amounts,\n        string calldata title,\n        uint8 payoutType\n    ) external returns (uint256 payoutId) {\n        return _createPayout(token, recipients, amounts, title, payoutType);\n    }\n\n    function createTemplate(\n        string calldata name,\n        address token,\n        address[] calldata recipients,\n        uint256[] calldata amounts\n    ) external returns (uint256 templateId) {\n        require(recipients.length == amounts.length, \"Length mismatch\");\n        require(recipients.length > 0, \"No recipients\");\n\n        for (uint256 i = 0; i < recipients.length; i++) {\n            require(recipients[i] != address(0), \"Zero recipient\");\n            require(amounts[i] > 0, \"Zero amount\");\n        }\n\n        templateId = nextTemplateId;\n        nextTemplateId++;\n\n        PayoutTemplate storage t = templates[templateId];\n        t.creator = msg.sender;\n        t.name = name;\n        t.token = token;\n        t.recipients = recipients;\n        t.amounts = amounts;\n\n        emit TemplateCreated(templateId, msg.sender, name);\n    }\n\n    function createPayoutFromTemplate(\n        uint256 templateId,\n        string calldata title,\n        uint8 payoutType\n    ) external returns (uint256 payoutId) {\n        PayoutTemplate storage t = templates[templateId];\n        require(t.creator == msg.sender, \"Not template creator\");\n\n        return _createPayout(t.token, t.recipients, t.amounts, title, payoutType);\n    }\n\n    function getTemplate(uint256 templateId) external view returns (\n        string memory name,\n        address token,\n        address[] memory recipients,\n        uint256[] memory amounts\n    ) {\n        PayoutTemplate storage t = templates[templateId];\n        return (t.name, t.token, t.recipients, t.amounts);\n    }\n\n    function fundPayout(uint256 payoutId, uint256 amount) external payable {\n        Payout storage p = payouts[payoutId];\n        require(!p.closed, \"Payout closed\");\n\n        if (p.token == address(0)) {\n            // 原生币\n            require(msg.value == amount, \"Value mismatch\");\n        } else {\n            // ERC20\n            require(msg.value == 0, \"No native\");\n            require(amount > 0, \"Zero amount\");\n            require(\n                IERC20(p.token).transferFrom(msg.sender, address(this), amount),\n                \"Transfer failed\"\n            );\n        }\n\n        p.fundedAmount += amount;\n        // require(p.fundedAmount <= p.totalAmount, \"Over funded\"); // Optional check\n\n        emit PayoutFunded(payoutId, msg.sender, amount);\n    }\n\n    function claim(uint256 payoutId) external {\n        Payout storage p = payouts[payoutId];\n        require(!p.closed, \"Payout closed\");\n\n        uint256 amount = claimable[payoutId][msg.sender];\n        require(amount > 0, \"Nothing to claim\");\n        require(p.fundedAmount >= amount, \"Not enough funded\");\n\n        // 更新状态（先改状态，再转钱，防重入）\n        claimable[payoutId][msg.sender] = 0;\n        p.fundedAmount -= amount;\n\n        if (p.token == address(0)) {\n            (bool ok, ) = msg.sender.call{value: amount}(\"\");\n            require(ok, \"Native transfer failed\");\n        } else {\n            require(\n                IERC20(p.token).transfer(msg.sender, amount),\n                \"ERC20 transfer failed\"\n            );\n        }\n\n        emit PayoutClaimed(payoutId, msg.sender, amount);\n    }\n\n    function closePayout(uint256 payoutId) external {\n        Payout storage p = payouts[payoutId];\n        require(msg.sender == p.creator, \"Not creator\");\n        require(!p.closed, \"Already closed\");\n        p.closed = true;\n        emit PayoutClosed(payoutId);\n    }\n\n    function withdrawRemaining(uint256 payoutId) external {\n        Payout storage p = payouts[payoutId];\n        require(msg.sender == p.creator, \"Not creator\");\n        require(p.closed, \"Not closed\");\n        uint256 amount = p.fundedAmount;\n        require(amount > 0, \"Nothing remaining\");\n\n        p.fundedAmount = 0;\n        if (p.token == address(0)) {\n            (bool ok, ) = msg.sender.call{value: amount}(\"\");\n            require(ok, \"Native transfer failed\");\n        } else {\n            require(\n                IERC20(p.token).transfer(msg.sender, amount),\n                \"ERC20 transfer failed\"\n            );\n        }\n\n        emit RemainingWithdrawn(payoutId, amount);\n    }\n\n    function getBatchClaimable(\n        uint256 payoutId,\n        address[] calldata users\n    ) external view returns (uint256[] memory amounts) {\n        amounts = new uint256[](users.length);\n        for (uint256 i = 0; i < users.length; i++) {\n            amounts[i] = claimable[payoutId][users[i]];\n        }\n    }\n}\n"
      }
    }
  }
}